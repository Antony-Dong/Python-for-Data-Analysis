## NumPy的应用-4

### 矩阵运算

NumPy 中提供了专门用于线性代数（linear algebra）的模块和表示矩阵的类型`matrix`，当然我们通过二维数组也可以表示一个矩阵，官方并不推荐使用`matrix`类而是建议使用二维数组，而且有可能在将来的版本中会移除`matrix`类。无论如何，利用这些已经封装好的类和函数，我们可以轻松愉快的实现线性代数中很多的操作。

#### 概念快速回顾

1. **向量**也叫**矢量**，是一个同时具有大小和方向，且满足平行四边形法则的几何对象。与向量相对的概念叫**标量**或**数量**，标量只有大小、绝大多数情况下没有方向。
2. 向量可以进行**加**、**减**、**数乘**、**点积**、**叉积**等运算。
3. **行列式**由向量组成，它的性质可以由向量解释。
4. 行列式的值可以使用**行列式公式**计算：$det(\boldsymbol{A})=\sum_{n!} \pm {a_{1\alpha}a_{2\beta} \cdots a_{n\omega}}$。
5. 高阶行列式可以用**代数余子式**展开成多个低阶行列式，如：$det(\boldsymbol{A})=a_{11}C_{11}+a_{12}C_{12}+ \cdots +a_{1n}C_{1n}$。
6. **矩阵**是由一系列元素排成的矩形阵列，矩阵里的元素可以是数字、符号或数学公式。
7. 矩阵可以进行**加法**、**减法**、**数乘**、**矩阵乘法**、**转置**等运算。
8. **逆矩阵**用$\boldsymbol{A^{-1}}$表示，$\boldsymbol{A}\boldsymbol{A^{-1}}=\boldsymbol{A^{-1}}\boldsymbol{A}=\boldsymbol{I}$；**奇异矩阵**没有逆矩阵。
9. **矩阵的秩**是指矩阵中线性无关的行/列向量的最大个数。

#### 矩阵对象的属性和方法

我们可以通过下面的代码来创建矩阵（`matrix`）对象，官方建议用普通的二维数组表示矩阵，这一点前面已经提到过了。

代码：

```Python
m1 = np.matrix('1 2 3; 4 5 6')
m1
```

> **说明**：`matrix`构造器可以传入类数组对象也可以传入字符串来构造矩阵对象。

输出：

```
matrix([[1, 2, 3],
        [4, 5, 6]])
```

代码：

```Python
m2 = np.asmatrix(np.array([[1, 1], [2, 2], [3, 3]]))
m2
```

> **说明**：`asmatrix`函数也可以用`mat`函数代替，这两个函数其实是同一个函数。

输出：

```
matrix([[1, 1],
        [2, 2],
        [3, 3]])
```

代码：

```Python
m1 * m2
```

输出：

```
matrix([[14, 14],
        [32, 32]])
```

> **说明**：注意`matrix`对象和`ndarray`对象乘法运算的差别，`matrix`对象的`*`运算是矩阵乘法运算。如果两个二维数组要做矩阵乘法运算，应该使用`@`运算符或`matmul`函数，而不是`*`运算符。

矩阵对象的属性如下表所示。

| 属性    | 说明                                      |
| ------- | ----------------------------------------- |
| `A`     | 获取矩阵对象对应的`ndarray`对象           |
| `A1`    | 获取矩阵对象对应的扁平化后的`ndarray`对象 |
| `I`     | 可逆矩阵的逆矩阵                          |
| `T`     | 矩阵的转置                                |
| `H`     | 矩阵的共轭转置                            |
| `shape` | 矩阵的形状                                |
| `size`  | 矩阵元素的个数                            |

矩阵对象的方法跟之前讲过的`ndarray`数组对象的方法基本差不多，此处不再进行赘述。

#### 线性代数模块

NumPy 的`linalg`模块中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的函数，它们跟 MATLAB 和 R 等语言所使用的是相同的行业标准线性代数库，下面的表格列出了`numpy`以及`linalg`模块中常用的跟线性代数相关的函数。

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `diag`        | 以一维数组的形式返回方阵的对角线元素或将一维数组转换为方阵（非对角元素元素为0） |
| `vdot`        | 向量的点积                                                   |
| `dot`         | 数组的点积                                                   |
| `inner`       | 数组的内积                                                   |
| `outer`       | 数组的叉积                                                   |
| `trace`       | 计算对角线元素的和                                           |
| `norm`        | 求模（范数）运算                                             |
| `det`         | 计算行列式的值（在方阵上计算会得到一个标量）                 |
| `matrix_rank` | 计算矩阵的秩                                                 |
| `eig`         | 计算矩阵的特征值（eigenvalue）和特征向量（eigenvector）      |
| `inv`         | 计算非奇异矩阵（$n$阶方阵）的逆矩阵                          |
| `pinv`        | 计算矩阵的摩尔-彭若斯（Moore-Penrose）广义逆                 |
| `qr`          | QR分解（把矩阵分解成一个正交矩阵与一个上三角矩阵的积）       |
| `svd`         | 计算奇异值分解（singular value decomposition）               |
| `solve`       | 解线性方程组$\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}$，其中$\boldsymbol{A}$是一个方阵 |
| `lstsq`       | 计算$\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}$的最小二乘解 |

下面我们简单尝试一下上面的函数，先试一试求逆矩阵。

代码：

```Python
m3 = np.array([[1., 2.], [3., 4.]])
m4 = np.linalg.inv(m3)
m4
```

输出：

```
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
```

代码：

```Python
np.around(m3 @ m4)
```

> **说明**：`around`函数对数组元素进行四舍五入操作，默认小数点后面的位数为0。

输出：

```
array([[1., 0.],
       [0., 1.]])
```

> **说明**：矩阵和它的逆矩阵做矩阵乘法会得到单位矩阵。

计算行列式的值。

代码：

```Python
m5 = np.array([[1, 3, 5], [2, 4, 6], [4, 7, 9]])
np.linalg.det(m5)
```

输出：

```
2
```

计算矩阵的秩。

代码：

```Python
np.linalg.matrix_rank(m5)
```

输出：

```
3
```

求解线性方程组。
$$
\begin{cases}
x_1 + 2x_2 + x_3 = 8 \\
3x_1 + 7x_2 + 2x_3 = 23 \\
2x_1 + 2x_2 + x_3 = 9
\end{cases}
$$

对于上面的线性方程组，我们可以用矩阵的形式来表示它，如下所示。
$$
A = \begin{bmatrix}
1 & 2 & 1\\
3 & 7 & 2\\
2 & 2 & 1
\end{bmatrix}, \quad
x = \begin{bmatrix}
x_1 \\
x_2\\
x_3
\end{bmatrix}, \quad
b = \begin{bmatrix}
8 \\
23\\
9
\end{bmatrix}
$$

$$
A \cdot x = b
$$

线性方程组有唯一解的条件：系数矩阵$ A $的秩等于增广矩阵$ Ab $的秩，而且跟未知数的个数相同。

代码：

```Python
A = np.array([[1, 2, 1], [3, 7, 2], [2, 2, 1]])
b = np.array([8, 23, 9]).reshape(-1, 1)
print(np.linalg.matrix_rank(A))
print(np.linalg.matrix_rank(np.hstack((A, b))))
```

> **说明**：使用数组对象的`reshape`方法调形时，如果其中一个参数为-1，那么该维度有多少个元素是通过数组元素个数（`size`属性）和其他维度的元素个数自动计算出来的。

输出：

```
3
3
```

代码：

```Python
np.linalg.solve(A, b)
```

输出：

```
array([[1.],
       [2.],
       [3.]])
```

> **说明**：上面的结果表示，线性方程组的解为：$ x_1 = 1, x_2 = 2, x_3 = 3 $。

下面是另一种求解线性方程组的方法。
$$
A \cdot x = b \\
A^{-1} \cdot A \cdot x = A^{-1}  \cdot b \\
I \cdot x = A^{-1}  \cdot b \\
x = A^{-1} \cdot b
$$
代码：

```Python
np.linalg.inv(A) @ b
```

输出：

```
array([[1.],
       [2.],
       [3.]])
```

### 多项式运算

除了数组，NumPy 中还封装了用于多项式运算的数据类型。多项式是变量的整数次幂与系数的乘积之和，形如：
$$
f(x)=a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x^{1} + a_0x^{0}
$$
在 NumPy 1.4版本之前，我们可以用`poly1d`类型来表示多项式，目前它仍然可用，但是官方提供了新的模块`numpy.polynomial`，它除了支持基本的幂级数多项式外，还可以支持切比雪夫多项式、拉盖尔多项式等。

#### 创建多项式对象

创建`poly1d`对象，例如：$\small{f(x)=3x^{2}+2x+1}$。

代码：

```python
p1 = np.poly1d([3, 2, 1])
p2 = np.poly1d([1, 2, 3])
print(p1)
print(p2)
```

输出：

```
   2
3 x + 2 x + 1
   2
1 x + 2 x + 3
```

#### 多项式的操作

获取多项式的系数。

代码：

```python
print(p1.coefficients)
print(p2.coeffs)
```

输出：

```
[3 2 1]
[1 2 3]
```

两个多项式的四则运算。

代码：

```python
print(p1 + p2)
print(p1 * p2)
```

输出：

```
   2
4 x + 4 x + 4
   4     3      2
3 x + 8 x + 14 x + 8 x + 3
```

带入$\small{x}$求多项式的值。

代码：

```python
print(p1(3))
print(p2(3))
```

输出：

```
34
18
```

多项式求导和不定积分。

代码：

```python
print(p1.deriv())
print(p1.integ())
```

输出：

```

6 x + 2
   3     2
1 x + 1 x + 1 x
```

求多项式的根。例如有多项式$\small{f(x)=x^2+3x+2}$，多项式的根即一元二次方程$\small{x^2+3x+2=0}$的解。

代码：

```python
p3 = np.poly1d([1, 3, 2])
print(p3.roots)
```

输出：

```
[-2. -1.]
```

如果使用`numpy.polynomial`模块的`Polynomial`类来表示多项式对象，那么对应的操作如下所示。

代码：

```python
from numpy.polynomial import Polynomial

p3 = Polynomial((2, 3, 1))
print(p3)           # 输出多项式
print(p3(3))        # 令x=3，计算多项式的值
print(p3.roots())   # 计算多项式的根
print(p3.degree())  # 获得多项式的次数
print(p3.deriv())   # 求导
print(p3.integ())   # 求不定积分
```

输出：

```
2.0 + 3.0·x + 1.0·x²
20.0
[-2. -1.]
2
3.0 + 2.0·x
0.0 + 2.0·x + 1.5·x² + 0.33333333·x³
```

#### 最小二乘解

`Polynomial`类还有一个名为`fit`的类方法，它可以给多项式求最小二乘解。所谓最小二乘解（least-squares solution），是用最小二乘法通过最小化误差的平方和来寻找数据的最佳匹配函数的系数。假设多项式为$\small{f(x)=ax+b}$，最小二乘解就是让下面的残差平方和$\small{RSS}$达到最小的$\small{a}$和$\small{b}$。
$$
RSS = \sum_{i=0}^{k}(f(x_i) - y_i)^{2}
$$
例如，我们想利用收集到的月收入和网购支出的历史数据来建立一个预测模型，以达到通过某人的月收入预测他网购支出金额的目标，下面是我们收集到的收入和网购支出的数据，保存在两个数组中。

```python
x = np.array([25000, 15850, 15500, 20500, 22000, 20010, 26050, 12500, 18500, 27300, 15000,  8300, 23320,  5250,  5800, 9100, 4800, 16000, 28500, 32000, 31300, 10800,  6750,  6020, 13300, 30020,  3200, 17300,  8835,  3500])
y = np.array([2599, 1400, 1120, 2560, 1900, 1200, 2320,  800, 1650, 2200,  980, 580, 1885,  600,  400,  800,  420, 1380, 1980, 3999, 3800,  725, 520,  420, 1200, 4020,  350, 1500,  560,  500])
```

我们可以先绘制散点图来了解两组数据是否具有正相关或负相关关系。正相关意味着数组`x`中较大的值对应到数组`y`中也是较大的值，而负相关则意味着数组`x`中较大的值对应到数组`y`中较小的值。

```python
import matplotlib.pyplot as plt

plt.figure(dpi=120)
plt.scatter(x, y, color='blue')
plt.show()
```

输出：

<img src="res/day06/in_out_scatter_plot.png" style="zoom:50%;">

如果需要定量的研究两组数据的相关性，我们可以计算协方差或相关系数，对应的 NumPy 函数分别是`cov`和`corrcoef`。

代码：

```python
np.corrcoef(x, y)
```

输出：

```
array([[1.        , 0.92275889],
       [0.92275889, 1.        ]])
```

> **说明**：相关系数是一个`-1`到`1`之间的值，越靠近`1` 说明正相关性越强，越靠近`-1`说明负相关性越强，靠近`0`则说明两组数据没有明显的相关性。上面月收入和网购支出之间的相关系数是`0.92275889`，说明二者是强正相关关系。

通过上面的操作，我们确定了收入和网购支出之前存在强正相关关系，于是我们可以这些数据来创建一个回归模型，即找到一条能够很好的拟合这些数据点的直线。这里，我们就可以用到上面提到的`fit`方法，具体的代码如下所示。

代码：

```python
from numpy.polynomial import Polynomial

Polynomial.fit(x, y, deg=1).convert().coef
```

> **说明**：`deg=1`说明回归模型最高次项就是1次项，回归模型形如$\small{y=ax+b}$；如果要生一个类似于$\small{y=ax^2+bx+c}$的模型，就需要设置`deg=2`，以此类推。

输出：

```
array([-2.94883437e+02,  1.10333716e-01])
```

根据上面输出的结果，我们的回归方程应该是$\small{y=0.110333716x-294.883437}$。我们将这个回归方程绘制到刚才的散点图上，红色的点是我们的预测值，蓝色的点是历史数据，也就是真实值。

代码：

```python
import matplotlib.pyplot as plt

plt.scatter(x, y, color='blue')
plt.scatter(x, 0.110333716 * x - 294.883437, color='red')
plt.plot(x, 0.110333716 * x - 294.883437, color='darkcyan')
plt.show()
```

输出：

<img src="res/day06/in_out_regression_result.png" style="zoom:50%;">

如果不使用`Polynomial`类型的`fit`方法，我们也可以通过 NumPy 提供的`polyfit`函数来完成同样的操作，有兴趣的读者可以自行研究。